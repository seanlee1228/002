import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { prisma } from "@/lib/prisma";
import { logDataChange, logError, getClientIP } from "@/lib/logger";
import { getLocale, createTranslator } from "@/lib/server-i18n";
import { ensureWeekPlan } from "@/lib/schedule-generator";
import { checkDeadline, getChinaToday, toChinaDateString } from "@/lib/deadline";
import { getScoringAuthority } from "@/lib/permissions";

// GET: 获取当日检查计划中的项目、班级列表、已有记录
export async function GET() {
  const locale = await getLocale();
  const t = createTranslator(locale, "api.errors");
  const session = await getServerSession(authOptions);
  if (!session?.user) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  const today = getChinaToday();

  try {
    const isGradeLeader = session.user.role === "GRADE_LEADER";
    const isDutyTeacher = session.user.role === "DUTY_TEACHER";
    const managedGrade = session.user.managedGrade;
    const hasGradeFilter = (isGradeLeader || isDutyTeacher) && managedGrade != null;
    const classWhere = hasGradeFilter ? { grade: managedGrade } : {};

    // 获取当日计划（含自动兜底）
    let plans = await prisma.dailyPlan.findMany({
      where: { date: today },
      include: {
        items: {
          include: { checkItem: true },
          orderBy: { sortOrder: "asc" },
        },
      },
    });

    let planSource: "manual" | "auto" | "fallback" | "none" = plans.length > 0 ? "manual" : "none";

    // 自动兜底：如果当天没有计划，先尝试用学期基线自动生成本周计划
    if (plans.length === 0) {
      try {
        const autoGenerated = await ensureWeekPlan(today);
        if (autoGenerated) {
          plans = await prisma.dailyPlan.findMany({
            where: { date: today },
            include: {
              items: {
                include: { checkItem: true },
                orderBy: { sortOrder: "asc" },
              },
            },
          });
          if (plans.length > 0) planSource = "auto";
        }
      } catch {
        // ensureWeekPlan 失败不影响原有逻辑
      }
    }

    // 仍然没有计划 → 回溯最近的工作日计划
    if (plans.length === 0) {
      const recentPlans = await prisma.dailyPlan.findMany({
        where: { date: { lt: today } },
        orderBy: { date: "desc" },
        take: 1,
        include: {
          items: {
            include: { checkItem: true },
            orderBy: { sortOrder: "asc" },
          },
        },
      });
      if (recentPlans.length > 0) {
        plans = recentPlans;
        planSource = "fallback";
      }
    }

    // 合并所有计划中的检查项（去重）
    const checkItemMap = new Map<string, typeof plans[0]["items"][0]["checkItem"]>();
    for (const plan of plans) {
      // 如果用户有年级限制，只取 targetGrade=null 或匹配的计划
      if (hasGradeFilter && plan.targetGrade != null && plan.targetGrade !== managedGrade) {
        continue;
      }
      for (const item of plan.items) {
        checkItemMap.set(item.checkItem.id, item.checkItem);
      }
    }

    // 也包括当天的动态临增项
    const dynamicItems = await prisma.checkItem.findMany({
      where: {
        isDynamic: true,
        date: today,
        isActive: true,
        ...(hasGradeFilter
          ? { OR: [{ targetGrade: null }, { targetGrade: managedGrade }] }
          : {}),
      },
    });
    for (const di of dynamicItems) {
      checkItemMap.set(di.id, di);
    }

    const checkItems = Array.from(checkItemMap.values()).sort(
      (a, b) => a.sortOrder - b.sortOrder
    );

    // 获取班级
    const classes = await prisma.class.findMany({
      where: classWhere,
      orderBy: [{ grade: "asc" }, { section: "asc" }],
    });

    // 获取已有的检查记录（含审计信息）
    const records = await prisma.checkRecord.findMany({
      where: {
        date: today,
        checkItem: { module: "DAILY" },
      },
      include: { checkItem: true },
    });
    // 注：scoredByRole, scoredByName, reviewAction, reviewedByName, originalScoredByName
    // 等审计字段为 CheckRecord 表的标量字段，会自动包含在查询结果中

    const recordsByClass = records.reduce(
      (acc, r) => {
        if (!acc[r.classId]) acc[r.classId] = [];
        acc[r.classId].push(r);
        return acc;
      },
      {} as Record<string, typeof records>
    );

    // 当前计划中的检查项 ID 集合，用于过滤已评记录
    const planItemIds = new Set(checkItems.map((item) => item.id));

    // 查询各班级近14天不达标记录，用于快速达标时优先抽查
    const fourteenDaysAgoDate = new Date();
    fourteenDaysAgoDate.setDate(fourteenDaysAgoDate.getDate() - 14);
    const recentFailedCutoff = toChinaDateString(fourteenDaysAgoDate);
    const recentFailedRecords = await prisma.checkRecord.findMany({
      where: {
        date: { gte: recentFailedCutoff, lt: today },
        passed: false,
        checkItem: { module: "DAILY" },
        classId: { in: classes.map((c) => c.id) },
      },
      select: { classId: true, checkItemId: true },
    });
    // 按班级分组：每个班级近期不达标的检查项 ID 集合
    const failedByClass: Record<string, Set<string>> = {};
    for (const r of recentFailedRecords) {
      if (!failedByClass[r.classId]) failedByClass[r.classId] = new Set();
      failedByClass[r.classId].add(r.checkItemId);
    }

    const scoringData = classes.map((cls) => {
      const classRecords = recordsByClass[cls.id] ?? [];
      // 只统计当前计划中存在的检查项的已评记录，避免计划变更后旧记录导致计数不一致
      const scoredItemIds = classRecords
        .filter((r) => planItemIds.has(r.checkItemId))
        .map((r) => r.checkItemId);
      const itemsWithRecords = checkItems.map((item) => {
        const record = classRecords.find((r) => r.checkItemId === item.id);
        return {
          ...item,
          record: record ?? null,
          hasBeenScored: scoredItemIds.includes(item.id),
        };
      });

      // 筛选出今日计划中、近14天有不达标记录的检查项 ID
      const recentFailedItemIds = Array.from(failedByClass[cls.id] ?? [])
        .filter((id) => planItemIds.has(id));

      return {
        ...cls,
        items: itemsWithRecords,
        scoredItemIds,
        recentFailedItemIds,
      };
    });

    // ===== Inspector Profile (检查画像) =====
    let inspectorProfile = null;
    const teacherId = session.user.id;
    const fourteenDaysAgo = new Date();
    fourteenDaysAgo.setDate(fourteenDaysAgo.getDate() - 14);
    const fourteenDaysAgoStr = toChinaDateString(fourteenDaysAgo);
    const thirtyDaysAgo = new Date();
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
    const thirtyDaysAgoStr = toChinaDateString(thirtyDaysAgo);

    try {
      // Teacher's records (14 days) for pass rate
      const teacherRecords14 = await prisma.checkRecord.findMany({
        where: {
          scoredById: teacherId,
          date: { gte: fourteenDaysAgoStr },
          checkItem: { module: "DAILY" },
        },
      });

      // School/grade records (14 days) for average - same scope as the user sees
      const scopeFilter = hasGradeFilter
        ? { classId: { in: classes.map((c) => c.id) } }
        : {};
      const schoolRecords14 = await prisma.checkRecord.findMany({
        where: {
          date: { gte: fourteenDaysAgoStr },
          checkItem: { module: "DAILY" },
          ...scopeFilter,
        },
      });

      // Pass rates
      const personalTotal = teacherRecords14.length;
      const personalPassed = teacherRecords14.filter((r) => r.passed === true).length;
      const personalPassRate = personalTotal > 0 ? Math.round((personalPassed / personalTotal) * 100) : 0;

      const schoolTotal = schoolRecords14.length;
      const schoolPassed = schoolRecords14.filter((r) => r.passed === true).length;
      const schoolAvgPassRate = schoolTotal > 0 ? Math.round((schoolPassed / schoolTotal) * 100) : 0;

      const deviation = personalPassRate - schoolAvgPassRate;

      // Severity distribution (30 days, fail records only)
      const teacherFails30 = await prisma.checkRecord.findMany({
        where: {
          scoredById: teacherId,
          date: { gte: thirtyDaysAgoStr },
          checkItem: { module: "DAILY" },
          passed: false,
        },
      });
      const schoolFails30 = await prisma.checkRecord.findMany({
        where: {
          date: { gte: thirtyDaysAgoStr },
          checkItem: { module: "DAILY" },
          passed: false,
          ...scopeFilter,
        },
      });

      const countSeverity = (recs: typeof teacherFails30) => {
        const dist = { minor: 0, moderate: 0, serious: 0 };
        for (const r of recs) {
          if (r.severity === "serious") dist.serious++;
          else if (r.severity === "moderate") dist.moderate++;
          else dist.minor++;
        }
        const total = dist.minor + dist.moderate + dist.serious;
        return {
          minor: total > 0 ? Math.round((dist.minor / total) * 100) : 0,
          moderate: total > 0 ? Math.round((dist.moderate / total) * 100) : 0,
          serious: total > 0 ? Math.round((dist.serious / total) * 100) : 0,
        };
      };

      const severityDist = countSeverity(teacherFails30);
      const schoolSeverityDist = countSeverity(schoolFails30);

      // Depth metrics
      const failsWithComment = teacherFails30.filter((r) => r.comment && r.comment.trim().length > 0).length;
      const commentRate = teacherFails30.length > 0 ? Math.round((failsWithComment / teacherFails30.length) * 100) : 0;

      // All-time scored days
      const allTeacherRecords = await prisma.checkRecord.findMany({
        where: { scoredById: teacherId, checkItem: { module: "DAILY" } },
        select: { date: true, classId: true },
      });
      const totalScoredDays = new Set(allTeacherRecords.map((r) => r.date)).size;

      // Average daily classes (14 days)
      const dailyClassMap: Record<string, Set<string>> = {};
      for (const r of teacherRecords14) {
        if (!dailyClassMap[r.date]) dailyClassMap[r.date] = new Set();
        dailyClassMap[r.date].add(r.classId);
      }
      const activeDays = Object.keys(dailyClassMap).length;
      const totalClassesInPeriod = Object.values(dailyClassMap).reduce((sum, s) => sum + s.size, 0);
      const avgDailyClasses = activeDays > 0 ? Math.round(totalClassesInPeriod / activeDays) : 0;

      // Guidance level
      let guidanceLevel: string;
      if (deviation > 8) guidanceLevel = "lenient_high";
      else if (deviation > 3) guidanceLevel = "lenient_mild";
      else if (deviation < -8) guidanceLevel = "strict_high";
      else if (deviation < -3) guidanceLevel = "strict_mild";
      else guidanceLevel = "balanced";

      inspectorProfile = {
        personalPassRate,
        schoolAvgPassRate,
        deviation,
        severityDist,
        schoolSeverityDist,
        commentRate,
        totalScoredDays,
        avgDailyClasses,
        guidanceLevel,
        personalTotal,
        schoolFailTotal: schoolFails30.length,
        teacherFailTotal: teacherFails30.length,
      };
    } catch (profileError) {
      // Profile computation failure should not block the main response
      console.error("Inspector profile computation error:", profileError);
    }

    return NextResponse.json({
      date: today,
      classes: scoringData,
      checkItems,
      hasPlan: plans.length > 0,
      planSource,
      inspectorProfile,
    });
  } catch (error) {
    console.error("Scoring GET error:", error);
    return NextResponse.json({ error: t("scoringLoadFailed") }, { status: 500 });
  }
}

// POST: 提交日评检查记录（达标/不达标）
export async function POST(request: Request) {
  const locale = await getLocale();
  const t = createTranslator(locale, "api.errors");
  const session = await getServerSession(authOptions);
  if (!session?.user) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }
  if (
    session.user.role !== "ADMIN" &&
    session.user.role !== "GRADE_LEADER" &&
    session.user.role !== "DUTY_TEACHER"
  ) {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  const ip = getClientIP(request);

  try {
    const body = await request.json();
    const { classId, records: recordInputs, method: submitMethod } = body as {
      classId: string;
      records: Array<{
        checkItemId: string;
        passed: boolean;
        severity?: string; // "minor" | "moderate" | "serious"，仅当 passed=false 时
        comment?: string;
      }>;
      method?: "quick_pass" | "item_by_item";
    };

    // 输入校验：类型 + 合理性
    if (!classId || typeof classId !== "string" || classId.length > 100) {
      return NextResponse.json({ error: t("invalidClassId") }, { status: 400 });
    }
    if (!Array.isArray(recordInputs) || recordInputs.length === 0 || recordInputs.length > 200) {
      return NextResponse.json({ error: t("invalidRecordCount") }, { status: 400 });
    }
    // 校验每条记录的字段
    for (const r of recordInputs) {
      if (!r.checkItemId || typeof r.checkItemId !== "string") {
        return NextResponse.json({ error: t("invalidCheckItemId") }, { status: 400 });
      }
      if (typeof r.passed !== "boolean") {
        return NextResponse.json({ error: t("invalidPassedField") }, { status: 400 });
      }
      if (r.severity && !["minor", "moderate", "serious"].includes(r.severity)) {
        return NextResponse.json({ error: t("invalidSeverity") }, { status: 400 });
      }
      if (r.comment && (typeof r.comment !== "string" || r.comment.length > 500)) {
        return NextResponse.json({ error: t("commentTooLong") }, { status: 400 });
      }
    }

    // 验证 session 用户仍存在于数据库（防止数据库重置后 JWT 过期）
    const dbUser = await prisma.user.findUnique({ where: { id: session.user.id }, select: { id: true } });
    if (!dbUser) {
      return NextResponse.json({ error: t("sessionExpired") }, { status: 401 });
    }

    // 年级权限检查
    if (
      (session.user.role === "GRADE_LEADER" || session.user.role === "DUTY_TEACHER") &&
      session.user.managedGrade != null
    ) {
      const targetClass = await prisma.class.findUnique({ where: { id: classId } });
      if (!targetClass || targetClass.grade !== session.user.managedGrade) {
        return NextResponse.json({ error: t("onlyOwnGradeScoring") }, { status: 403 });
      }
    }

    const today = getChinaToday();

    // 时效性校验：日评仅限当天录入
    const deadline = checkDeadline("daily", today, session.user.role, locale);
    if (!deadline.allowed) {
      return NextResponse.json({ error: t("dailyScoringExpired") }, { status: 403 });
    }

    const myAuthority = getScoringAuthority(session.user.role);
    const myId = session.user.id;
    const myRole = session.user.role;
    const myName = session.user.name;

    // 批量查询已有记录，用于权限判断
    const checkItemIds = recordInputs.map((r) => r.checkItemId);
    const existingRecords = await prisma.checkRecord.findMany({
      where: {
        classId,
        date: today,
        checkItemId: { in: checkItemIds },
      },
    });
    const existingMap = new Map(
      existingRecords.map((r) => [r.checkItemId, r])
    );

    // 检查是否有低权限覆盖高权限的冲突
    const blockedItems: string[] = [];
    for (const r of recordInputs) {
      const existing = existingMap.get(r.checkItemId);
      if (!existing) continue;
      const existingAuthority = getScoringAuthority(existing.scoredByRole ?? "DUTY_TEACHER");
      // 低权限不可覆盖高权限（非本人）
      if (myAuthority < existingAuthority && myId !== existing.scoredById) {
        blockedItems.push(r.checkItemId);
      }
    }
    if (blockedItems.length > 0 && blockedItems.length === recordInputs.length) {
      // 全部被拦截
      return NextResponse.json(
        { error: t("scoringBlockedByHigherAuthority"), blockedItems },
        { status: 403 }
      );
    }

    // 构建事务操作
    const operations = [];
    const skippedCount = blockedItems.length;

    for (const r of recordInputs) {
      // 跳过被拦截的项
      if (blockedItems.includes(r.checkItemId)) continue;

      const existing = existingMap.get(r.checkItemId);
      const passed = r.passed;
      const severity = passed ? null : (r.severity ?? null);
      const comment = r.comment ?? null;

      if (!existing) {
        // 场景1：首次评分 — 评分人即为原始评分人
        operations.push(
          prisma.checkRecord.create({
            data: {
              classId,
              checkItemId: r.checkItemId,
              date: today,
              passed,
              severity,
              comment,
              scoredById: myId,
              scoredByRole: myRole,
              scoredByName: myName,
              originalScoredById: myId,
              originalScoredByName: myName,
              originalScoredByRole: myRole,
              originalPassed: passed,
              originalSeverity: severity,
              originalScoredAt: new Date(),
            },
          })
        );
      } else {
        const existingAuthority = getScoringAuthority(existing.scoredByRole ?? "DUTY_TEACHER");
        const isSameUser = myId === existing.scoredById;

        if (isSameUser) {
          // 场景2：自己改自己 — 直接更新，保持审计字段不变
          operations.push(
            prisma.checkRecord.update({
              where: { id: existing.id },
              data: { passed, severity, comment },
            })
          );
        } else if (myAuthority > existingAuthority) {
          // 场景3：高权限修正低权限 — 保留原始评分 + 写入审核信息
          operations.push(
            prisma.checkRecord.update({
              where: { id: existing.id },
              data: {
                passed,
                severity,
                comment,
                scoredById: myId,
                scoredByRole: myRole,
                scoredByName: myName,
                // 仅首次修正时保存原始评分（不反复覆盖）
                ...(existing.originalScoredById == null ? {
                  originalScoredById: existing.scoredById,
                  originalScoredByName: existing.scoredByName,
                  originalScoredByRole: existing.scoredByRole,
                  originalPassed: existing.passed,
                  originalSeverity: existing.severity,
                  originalScoredAt: existing.updatedAt,
                } : {}),
                reviewedById: myId,
                reviewedByName: myName,
                reviewedByRole: myRole,
                reviewedAt: new Date(),
                reviewAction: "revised",
              },
            })
          );
        } else {
          // 场景4：同级别不同人 — 允许覆盖，保留原始
          operations.push(
            prisma.checkRecord.update({
              where: { id: existing.id },
              data: {
                passed,
                severity,
                comment,
                scoredById: myId,
                scoredByRole: myRole,
                scoredByName: myName,
                ...(existing.originalScoredById == null ? {
                  originalScoredById: existing.scoredById,
                  originalScoredByName: existing.scoredByName,
                  originalScoredByRole: existing.scoredByRole,
                  originalPassed: existing.passed,
                  originalSeverity: existing.severity,
                  originalScoredAt: existing.updatedAt,
                } : {}),
              },
            })
          );
        }
      }
    }

    if (operations.length > 0) {
      await prisma.$transaction(operations);
    }

    logDataChange("UPSERT", session.user, "CheckRecord", {
      classId,
      date: today,
      itemCount: recordInputs.length,
      method: submitMethod || "item_by_item",
      skippedByAuthority: skippedCount,
      records: recordInputs,
    }, ip);

    return NextResponse.json({
      success: true,
      skippedCount,
      ...(skippedCount > 0 ? { message: t("someItemsBlockedByReview") } : {}),
    });
  } catch (error) {
    logError("提交日评记录", session.user, error, ip);
    return NextResponse.json({ error: t("scoringSubmitFailed") }, { status: 500 });
  }
}
